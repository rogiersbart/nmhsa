% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nmhsa.R
\name{nmhsa}
\alias{nmhsa}
\title{Nested multiresolution hierarchical simulated annealing}
\usage{
nmhsa(
  ti,
  dimensions = NULL,
  start_after = NULL,
  stop_after = NULL,
  stop_rejected = NULL,
  stop_at = 1e-06,
  order = NULL,
  distance = NULL,
  cool = 0.9,
  levels = 2,
  ti_merged = NULL,
  ti_splitted = NULL,
  merge_pairs = NULL,
  merge_distance = NULL,
  merge_stop_after = NULL,
  split_distance = NULL,
  split_stop_after = NULL
)
}
\arguments{
\item{ti}{The original training image (2D array).}

\item{dimensions}{Dimensions for the reconstruction (vector of length 2 or
3). Defaults to the dimensions of \code{ti}.}

\item{start_after}{Number of iterations for determining the initial simulated
annealing temperature. Defaults to 0.1\% of the total amount of pixels in
the reconstruction.}

\item{stop_after}{Maximum number of iterations. Defaults to the amount of
pixels in the reconstruction. Can be a vector for different values per
phase.}

\item{stop_rejected}{Maximum number of consecutively rejected iterations.
Defaults to 1\% of the total amount of pixels in the reconstruction.}

\item{stop_at}{Target precision. Defaults to \code{1e-6}.}

\item{order}{Integer vector with the phase order for hierarchical simulation.
Defaults to the least to the most occurring phase.}

\item{distance}{Distance, in pixels, up to which to investigate the
structural descriptors. Defaults to 1/4th of the minimum of \code{dim(ti)} and
\code{dimensions}.}

\item{cool}{Simulated annealing cooling factor. Must be lower than one.
Defaults to \code{0.9}.}

\item{levels}{Amount of grid levels (or resolutions) to use for the
reconstruction. Defaults to \code{2}. Can be a vector to use different levels
for different phases.}

\item{ti_merged}{Merged version of \code{ti}. Typically obtained through
\code{\link[=phase_merge]{phase_merge()}}.}

\item{ti_splitted}{Splitted version of \code{ti_merged}. Typically obtained
through \code{\link[=phase_split]{phase_split()}}.}

\item{merge_pairs}{List of length 2 vectors, indicating for which pairs of
phases optimisation should again be performed after merging all subphases
again to their original phase (transition from the state of \code{ti_splitted}
to the state of \code{ti_merged}).}

\item{merge_distance}{Distance, in pixels, up to which to investigate the
structural descriptors for the merging step. Defaults to 1/4th of the
minimum of \code{dim(ti)} and \code{dimensions}. Should be a vector of the same
length as \code{merge_pairs}.}

\item{merge_stop_after}{Maximum number of iterations for the merging step.
Defaults to the amount of pixels in the reconstruction. Can be a vector for
different values per phase.}

\item{split_distance}{Distance, in pixels, up to which to investigate the
structural descriptors for the splitting step. Defaults to 1/4th of the
minimum of \code{dim(ti)} and \code{dimensions}.}

\item{split_stop_after}{Maximum number of iterations for the splitting step.
Defaults to the amount of pixels in the reconstruction.}
}
\value{
A reconstructed 2D or 3D array.
}
\description{
This algorithm extends \code{\link[=mhsa]{mhsa()}} by introducing the nested approach, meaning
it automatically handles identified subphases (which are split by the user,
and merged again by the algorithm), and allows handling things like
inclusions by a splitting step at the end of the simulation (phases merged,
or rather rearranged, by the user, and split again by the algorithm).
}
\details{
A more general approach to the phase merging and splitting would be possible,
where the user has control of every step in the simulation, but this is
currently not implemented.
}
\references{
\link{https://doi.org/10.1103/PhysRevE.100.053316}
}
\seealso{
\code{\link[=hsa]{hsa()}}, \code{\link[=mhsa]{mhsa()}}, \code{\link[=phase_merge]{phase_merge()}}, \code{\link[=phase_split]{phase_split()}}
}
